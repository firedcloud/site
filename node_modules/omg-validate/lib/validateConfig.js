"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = validateConfig;

var v = _interopRequireWildcard(require("./validatorsConfig"));

var _validatorsBase = require("./validatorsBase");

var _types = require("./types");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/* eslint no-shadow: ["error", { "allow": ["state"] }] */
function validateConfig(config, rootError) {
  if (typeof config !== 'object' || !config) {
    rootError('Config is malformed'); // Cannot perform any other checks when confirm is malformed
    // Return early.

    return;
  }

  const root = {
    path: [],
    value: config,
    visited: [],
    onError: rootError // +Local validator mixins

  };

  function validateTOutput({
    state
  }) {
    (0, _validatorsBase.validateWith)(state, 'help', false, v.string);
    (0, _validatorsBase.validateWith)(state, 'type', true, (0, _validatorsBase.enumValues)(_types.OUTPUT_TYPES));
    (0, _validatorsBase.validateAssocObject)(state, 'properties', state.value.type === 'object', ({
      state
    }) => {
      validateTOutput({
        state
      });
    });
  }

  function validateTArgument({
    state,
    validateIn
  }) {
    (0, _validatorsBase.validateWith)(state, 'help', false, v.string);
    (0, _validatorsBase.validateWith)(state, 'type', true, (0, _validatorsBase.enumValues)(_types.INPUT_TYPES));

    if (validateIn) {
      (0, _validatorsBase.validateWith)(state, 'in', true, (0, _validatorsBase.enumValues)(['query', 'path', 'requestBody', 'header']));
    }

    (0, _validatorsBase.validateWith)(state, 'enum', false, (0, _validatorsBase.array)(v.string));
    (0, _validatorsBase.validateObject)(state, 'range', false, ({
      state
    }) => {
      (0, _validatorsBase.validateWith)(state, 'min', false, v.number);
      (0, _validatorsBase.validateWith)(state, 'max', false, v.number);
    });
    (0, _validatorsBase.validateWith)(state, 'required', false, v.boolean);
    (0, _validatorsBase.validateWith)(state, 'default', false, v.any);
    (0, _validatorsBase.validateAssocObject)(state, 'properties', state.value.type === 'object', ({
      state
    }) => {
      validateTArgument({
        state,
        validateIn: false
      });
    });
  } // -Local validator mixins


  (0, _validatorsBase.validate)(root, 'omg', true, ({
    state,
    error
  }) => {
    if (typeof state.value !== 'number') {
      error('must be a valid number');
    } else if (state.value !== 1) {
      error(`version expected to be 1, found: ${state.value}`);
    }
  });
  (0, _validatorsBase.validateObject)(root, 'info', true, ({
    state
  }) => {
    ;
    ['title', 'version', 'description'].forEach(prop => {
      (0, _validatorsBase.validateWith)(state, prop, true, v.string);
    });
    (0, _validatorsBase.validateObject)(state, 'contact', false, ({
      state
    }) => {
      ;
      ['name', 'url', 'email'].forEach(prop => {
        (0, _validatorsBase.validateWith)(state, prop, false, v.string);
      });
    });
    (0, _validatorsBase.validateObject)(state, 'license', false, ({
      state
    }) => {
      ;
      ['name', 'url'].forEach(prop => {
        (0, _validatorsBase.validateWith)(state, prop, false, v.string);
      });
    });
  });
  (0, _validatorsBase.validate)(root, 'lifecycle', false, ({
    state
  }) => {
    (0, _validatorsBase.validate)(state, 'startup', false, ({
      state
    }) => {
      (0, _validatorsBase.validateWith)(state, 'command', true, (0, _validatorsBase.oneOf)(v.string, (0, _validatorsBase.array)(v.string)));
    });
    (0, _validatorsBase.validate)(state, 'shutdown', false, ({
      state
    }) => {
      (0, _validatorsBase.validateWith)(state, 'command', true, (0, _validatorsBase.oneOf)(v.string, (0, _validatorsBase.array)(v.string)));
      (0, _validatorsBase.validateWith)(state, 'timeout', false, v.number);
    });
  });
  (0, _validatorsBase.validateAssocObject)(root, 'actions', true, ({
    state
  }) => {
    (0, _validatorsBase.validateWith)(state, 'help', false, v.string);
    (0, _validatorsBase.validateObject)(state, 'format', false, ({
      state
    }) => {
      (0, _validatorsBase.validateWith)(state, 'command', true, (0, _validatorsBase.oneOf)(v.string, (0, _validatorsBase.array)(v.string)));
    });
    (0, _validatorsBase.validateAssocObject)(state, 'events', false, ({
      state
    }) => {
      (0, _validatorsBase.validateWith)(state, 'help', false, v.string);
      (0, _validatorsBase.validateObject)(state, 'http', true, ({
        state
      }) => {
        (0, _validatorsBase.validateWith)(state, 'port', true, v.number);
        (0, _validatorsBase.validateObject)(state, 'subscribe', true, ({
          state
        }) => {
          (0, _validatorsBase.validateWith)(state, 'path', true, v.pathname);
          (0, _validatorsBase.validateWith)(state, 'method', true, (0, _validatorsBase.enumValues)(_types.HTTP_METHODS));
          (0, _validatorsBase.validateWith)(state, 'contentType', false, (0, _validatorsBase.enumValues)(_types.CONTENT_TYPES));
        });
        (0, _validatorsBase.validateObject)(state, 'unsubscribe', false, ({
          state
        }) => {
          (0, _validatorsBase.validateWith)(state, 'path', true, v.pathname);
          (0, _validatorsBase.validateWith)(state, 'method', true, (0, _validatorsBase.enumValues)(_types.HTTP_METHODS));
        });
      });
      (0, _validatorsBase.validateObject)(state, 'output', false, ({
        state
      }) => {
        (0, _validatorsBase.validateWith)(state, 'actions', false, v.any);
        (0, _validatorsBase.validateWith)(state, 'contentType', false, (0, _validatorsBase.enumValues)(_types.CONTENT_TYPES));
        validateTOutput({
          state
        });
      });
      (0, _validatorsBase.validateAssocObject)(state, 'arguments', false, ({
        state
      }) => {
        validateTArgument({
          state,
          validateIn: true
        });
      });
    });
    (0, _validatorsBase.validateObject)(state, 'rpc', false, ({
      state
    }) => {
      (0, _validatorsBase.validateWith)(state, 'port', true, v.number);
      (0, _validatorsBase.validateObject)(state, 'framework', true, ({
        state
      }) => {
        (0, _validatorsBase.validateObject)(state, 'grpc', true, ({
          state
        }) => {
          (0, _validatorsBase.validateWith)(state, 'version', true, v.number);
          (0, _validatorsBase.validateObject)(state, 'proto', true, ({
            state
          }) => {
            (0, _validatorsBase.validateWith)(state, 'path', true, v.string);
          });
        });
      });
      (0, _validatorsBase.validateObject)(state, 'client', true, ({
        state
      }) => {
        (0, _validatorsBase.validateWith)(state, 'endpoint', true, v.string);
        (0, _validatorsBase.validateWith)(state, 'port', true, v.number);
        (0, _validatorsBase.validateWith)(state, 'tls', true, v.boolean);
      });
    });
    (0, _validatorsBase.validateObject)(state, 'http', false, ({
      state
    }) => {
      (0, _validatorsBase.validateWith)(state, 'method', true, (0, _validatorsBase.enumValues)(_types.HTTP_METHODS));
      (0, _validatorsBase.validateWith)(state, 'contentType', false, (0, _validatorsBase.enumValues)(_types.CONTENT_TYPES));

      if (state.value.port) {
        (0, _validatorsBase.validateWith)(state, 'path', true, v.pathname);
        (0, _validatorsBase.validateWith)(state, 'port', true, v.number);
        (0, _validatorsBase.validateWith)(state, 'url', false, v.notDefined('when port is defined'));
      } else {
        (0, _validatorsBase.validateWith)(state, 'path', false, v.notDefined('when url is defined'));
        (0, _validatorsBase.validateWith)(state, 'port', false, v.notDefined('when url is defined'));
        (0, _validatorsBase.validateWith)(state, 'url', true, v.string);
      }
    });
    (0, _validatorsBase.validateAssocObject)(state, 'arguments', false, ({
      state
    }) => {
      validateTArgument({
        state,
        validateIn: true
      });
    });
    (0, _validatorsBase.validateObject)(state, 'output', true, ({
      state
    }) => {
      (0, _validatorsBase.validateWith)(state, 'contentType', false, (0, _validatorsBase.enumValues)(_types.CONTENT_TYPES));
      validateTOutput({
        state
      });
    });
  });
  (0, _validatorsBase.validateWith)(root, 'hostedExternally', false, v.boolean);
  (0, _validatorsBase.validateAssocObject)(root, 'environment', false, ({
    state
  }) => {
    (0, _validatorsBase.validateWith)(state, 'type', true, (0, _validatorsBase.enumValues)(_types.ENV_TYPES));
    (0, _validatorsBase.validateWith)(state, 'pattern', false, v.string);
    (0, _validatorsBase.validateWith)(state, 'sensitive', false, v.boolean);
    (0, _validatorsBase.validateWith)(state, 'help', false, v.string);

    if (typeof state.value.required !== 'undefined') {
      (0, _validatorsBase.validateWith)(state, 'default', false, v.notDefined('when port is defined'));
      (0, _validatorsBase.validateWith)(state, 'required', false, v.boolean);
    } else {
      (0, _validatorsBase.validateWith)(state, 'required', false, v.notDefined('when port is defined'));
      (0, _validatorsBase.validateWith)(state, 'default', false, v.string);
    }
  });
  (0, _validatorsBase.validateAssocObject)(root, 'volumes', false, ({
    state
  }) => {
    (0, _validatorsBase.validateWith)(state, 'target', true, v.string);
    (0, _validatorsBase.validateWith)(state, 'persist', false, v.boolean);
  });
  (0, _validatorsBase.validateObject)(root, 'metrics', false, ({
    state
  }) => {
    (0, _validatorsBase.validateWith)(state, 'ssl', false, v.boolean);
    (0, _validatorsBase.validateWith)(state, 'port', true, v.number);
    (0, _validatorsBase.validateWith)(state, 'uri', true, v.string);
  });
  (0, _validatorsBase.validateObject)(root, 'scale', false, ({
    state
  }) => {
    (0, _validatorsBase.validateWith)(state, 'metric_type', false, (0, _validatorsBase.enumValues)(['cpu', 'mem']));
    (0, _validatorsBase.validateWith)(state, 'metric_agg', false, (0, _validatorsBase.enumValues)(['avg', 'min', 'max', 'mean', 'mode']));
    (0, _validatorsBase.validateWith)(state, 'metric_interval', false, v.number);
    (0, _validatorsBase.validateWith)(state, 'metric_target', false, v.number);
    (0, _validatorsBase.validateWith)(state, 'min', false, v.number);
    (0, _validatorsBase.validateWith)(state, 'max', false, v.number);
    (0, _validatorsBase.validateWith)(state, 'desired', false, v.number);
    (0, _validatorsBase.validateWith)(state, 'cooldown', false, v.number);
  });
  (0, _validatorsBase.validateAssocObject)(root, 'forwards', false, ({
    state
  }) => {
    (0, _validatorsBase.validateWith)(state, 'help', false, v.string);
    (0, _validatorsBase.validateObject)(state, 'http', true, ({
      state
    }) => {
      (0, _validatorsBase.validateWith)(state, 'path', true, v.pathname);
      (0, _validatorsBase.validateWith)(state, 'port', true, v.number);
    });
  });
  (0, _validatorsBase.validateObject)(root, 'health', false, ({
    state
  }) => {
    (0, _validatorsBase.validateObject)(state, 'http', true, ({
      state
    }) => {
      (0, _validatorsBase.validateWith)(state, 'path', true, v.pathname);
      (0, _validatorsBase.validateWith)(state, 'port', true, v.number);
    });
  });
}