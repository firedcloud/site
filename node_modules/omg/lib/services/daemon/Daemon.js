"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _execa = _interopRequireDefault(require("execa"));

var _eventKit = require("event-kit");

var logger = _interopRequireWildcard(require("../../logger"));

var _errors = require("../../errors");

var _common = require("../../common");

var _docker = require("../docker");

var _DaemonLogs = _interopRequireDefault(require("./DaemonLogs"));

var _buildForDaemon = _interopRequireDefault(require("./buildForDaemon"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Daemon {
  constructor({
    configPaths,
    microserviceConfig
  }) {
    _defineProperty(this, "configPaths", void 0);

    _defineProperty(this, "microserviceConfig", void 0);

    _defineProperty(this, "containerState", void 0);

    this.configPaths = configPaths;
    this.microserviceConfig = microserviceConfig;
    this.containerState = null;

    _common.lifecycleDisposables.add(this);
  }

  async start({
    image,
    envs,
    raw,
    inheritEnv
  }) {
    if (this.containerState) {
      throw new _errors.CLIError('Cannot start when already started');
    }

    const imageName = image || (await (0, _docker.getImageName)({
      configPath: this.configPaths.docker
    })).name;

    if (!image) {
      // If an image name is not specified, call build
      await (0, _buildForDaemon.default)({
        imageName,
        configPath: this.configPaths.docker,
        raw
      });
    }

    logger.spinnerStart('Starting Docker container');

    try {
      const {
        container,
        portsMap
      } = await (0, _docker.getContainer)({
        envs,
        image: imageName,
        config: this.microserviceConfig,
        inheritEnv
      });
      this.containerState = {
        container,
        portsMap,
        subscriptions: new _eventKit.CompositeDisposable()
      };

      _common.lifecycleDisposables.add(this);

      await container.start();
      logger.spinnerSucceed('Successfully started Docker container');
    } catch (error) {
      this.containerState = null;
      logger.spinnerFail('Starting Docker container failed');
      throw error;
    }
  }

  async getLogs() {
    const {
      containerState
    } = this;

    if (!containerState) {
      throw new _errors.CLIError('Failed to get logs on a stopped Daemon');
    }

    const daemonLogger = new _DaemonLogs.default(containerState.container);
    await daemonLogger.start();
    containerState.subscriptions.add(daemonLogger);
    daemonLogger.onDidDestroy(() => {
      containerState.subscriptions.delete(daemonLogger);
    });
    return daemonLogger;
  }

  async ping() {
    const {
      containerState
    } = this;

    if (!containerState) {
      return false;
    }

    const status = await (0, _docker.pingContainer)({
      config: this.microserviceConfig,
      container: containerState.container.id,
      portsMap: containerState.portsMap
    });
    return status;
  }

  async isRunning() {
    const {
      containerState
    } = this;

    if (!containerState) {
      return false;
    }

    return (0, _docker.isContainerRunning)(containerState.container.id);
  }

  getContainerPort(sourcePort) {
    const {
      containerState
    } = this;

    if (!containerState) {
      throw new _errors.CLIError(`Failed to getContainerPort#${sourcePort} while the container is not running`);
    }

    const mappedPort = containerState.portsMap.get(sourcePort);

    if (!mappedPort) {
      throw new _errors.CLIError(`Mapped port for port '${sourcePort}' not found`);
    }

    return mappedPort;
  } // Stops gracefully (presumably.)


  async stop() {
    logger.info('Cleaning up the Docker state');
    const {
      containerState
    } = this;

    if (!containerState) {
      return;
    }

    this.containerState = null;
    containerState.subscriptions.dispose();
    await containerState.container.stop();
    await containerState.container.remove();

    _common.lifecycleDisposables.delete(this);
  } // Terminate is synchronous


  terminate() {
    const {
      containerState
    } = this;

    if (!containerState) {
      return;
    }

    this.containerState = null;

    try {
      containerState.subscriptions.dispose();

      _execa.default.sync('docker', ['kill', containerState.container.id], {
        stdio: 'ignore'
      });

      _execa.default.sync('docker', ['rm', containerState.container.id], {
        stdio: 'ignore'
      });
    } catch (_) {
      /* Ignore kill errors - If this fails, God save us. */
    }

    _common.lifecycleDisposables.delete(this);
  }

  dispose() {
    this.terminate();
  }

}

exports.default = Daemon;