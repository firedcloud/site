"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildImage;

var _path = _interopRequireDefault(require("path"));

var _readline = _interopRequireDefault(require("readline"));

var _errors = require("../../errors");

var _common = require("../../common");

var _pingDaemon = _interopRequireDefault(require("./pingDaemon"));

var _common2 = require("./common");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function buildImage(options) {
  if (!(await (0, _pingDaemon.default)())) {
    throw new _errors.CLIError('Docker daemon must be running before build images');
  }

  const stream = await _common2.dockerode.buildImage( // @ts-ignore: Dockerode has bad typings and requires src
  {
    context: _path.default.dirname(options.configPath)
  }, {
    t: options.name
  });

  const lineInterface = _readline.default.createInterface({
    input: stream,
    terminal: false
  });

  return new Promise((resolve, reject) => {
    lineInterface.on('line', line => {
      const parsedLine = JSON.parse(line);

      if (parsedLine.stream) {
        // Ignore non-stream status
        const trimmed = parsedLine.stream.trim();

        if (trimmed.length) {
          options.onLog(trimmed);
        }
      } else if (parsedLine.error) {
        const debugMessage = (0, _common.getCliOptions)().debug ? '' : ' (run with --debug for build log)';
        reject(new _errors.CLIError(`Building Docker image failed${debugMessage}: ${parsedLine.error}`));
      }
    });
    lineInterface.on('close', resolve);
  });
}