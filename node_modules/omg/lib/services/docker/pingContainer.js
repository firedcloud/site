"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pingContainer;

var _got = _interopRequireDefault(require("got"));

var _errors = require("../../errors");

var _waitForHttpPortOpen = _interopRequireDefault(require("../../helpers/waitForHttpPortOpen"));

var _isContainerRunning = _interopRequireDefault(require("./isContainerRunning"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const MAX_ATTEMPTS = 10;
const ATTEMPT_TIMEOUT = 1000; // 1s

async function pingContainer({
  container,
  config,
  portsMap
}) {
  if (!(await (0, _isContainerRunning.default)(container))) {
    return false;
  }

  const {
    health
  } = config;

  if (!health || !health.http) {
    const firstPort = Array.from(portsMap.values())[0];

    if (firstPort) {
      const status = await (0, _waitForHttpPortOpen.default)(firstPort, 10);

      if (status) {
        // Port opened up
        return true;
      }
    } // Assume it works I guess
    // Wait 2 seconds, just in case...


    await new Promise(resolve => setTimeout(resolve, 2000));
    return true;
  }

  const healthCheckPort = portsMap.get(health.http.port);

  if (!healthCheckPort) {
    // Should never happen but just in case.
    throw new _errors.CLIError(`Mapped port for healthcheck port '${health.http.port}' not found`);
  }

  const uri = `http://localhost:${healthCheckPort}${health.http.path}`;

  for (let attempt = 0; attempt < MAX_ATTEMPTS; attempt += 1) {
    try {
      // eslint-disable-next-line no-await-in-loop
      const response = await (0, _got.default)(uri, {
        timeout: ATTEMPT_TIMEOUT
      });

      if (response.statusCode >= 200 && response.statusCode < 400) {
        return true;
      }
    } catch (_) {}
    /* No Op */
    // eslint-disable-next-line no-await-in-loop


    await new Promise(resolve => setTimeout(resolve, ATTEMPT_TIMEOUT));
  }

  return false;
}