"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sbFs = _interopRequireDefault(require("sb-fs"));

var _stripAnsi = _interopRequireDefault(require("strip-ansi"));

var _bodyParser = _interopRequireDefault(require("body-parser"));

var _express = _interopRequireDefault(require("express"));

var _eventKit = require("event-kit");

var _omgUi = _interopRequireDefault(require("omg-ui"));

var logger = _interopRequireWildcard(require("../../logger"));

var _mapToArgs = _interopRequireDefault(require("../../helpers/mapToArgs"));

var _config = require("../config");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Note: Should always be positive
const MAX_HISTORY_LENGTH = 500;

class DashboardHttpServer {
  constructor(options) {
    _defineProperty(this, "port", void 0);

    _defineProperty(this, "configPaths", void 0);

    _defineProperty(this, "appStatus", void 0);

    _defineProperty(this, "microserviceConfig", void 0);

    _defineProperty(this, "executeAction", void 0);

    _defineProperty(this, "serverRef", void 0);

    _defineProperty(this, "emitter", void 0);

    _defineProperty(this, "subscriptions", void 0);

    _defineProperty(this, "eventListeners", void 0);

    _defineProperty(this, "logHistory", void 0);

    this.port = options.port;
    this.configPaths = options.configPaths;
    this.appStatus = options.appStatus;
    this.microserviceConfig = options.microserviceConfig;
    this.executeAction = options.executeAction;
    this.serverRef = null;
    this.emitter = new _eventKit.Emitter();
    this.subscriptions = new _eventKit.CompositeDisposable();
    this.eventListeners = new Set();
    this.logHistory = [];
    this.subscriptions.add(this.emitter); // Forward console logs to the UI

    const handleConsoleLogs = ({
      severity,
      contents
    }) => {
      this.logToHistory('console-log', {
        severity,
        contents: (0, _stripAnsi.default)(contents)
      });
    };

    logger.logConsumers.add(handleConsoleLogs);
    this.subscriptions.add(new _eventKit.Disposable(() => {
      logger.logConsumers.delete(handleConsoleLogs);
    }));
  }

  getPort() {
    return this.port;
  }

  async start() {
    const app = (0, _express.default)();
    app.use(_bodyParser.default.json());
    app.use(_express.default.static(_omgUi.default)); // API Routes

    app.get('/api/config', (req, res) => {
      res.json(this.microserviceConfig);
    });
    app.get('/api/configRaw', (req, res) => {
      res.sendFile(this.configPaths.microservice);
    });
    app.get('/api/events', (req, res) => {
      // 24 hours
      req.setTimeout(1000 * 60 * 60 * 24, () => {
        /* No op */
      });
      res.writeHead(200, {
        'Transfer-Encoding': 'chunked',
        'Content-Type': 'application/json',
        'Cache-Control': 'no-cache'
      }); // Bootstrap events:

      this.publishEvent('config-updated', {
        config: this.microserviceConfig,
        validationErrors: (0, _config.getValidationErrors)(this.microserviceConfig)
      }, res);
      this.publishEvent('app-status-updated', {
        status: this.appStatus
      }, res);
      this.logHistory.forEach(({
        type,
        payload
      }) => {
        this.publishEvent(type, payload, res);
      }); // GC Handlers:

      res.on('end', () => {
        this.eventListeners.delete(res);
      });
      this.eventListeners.add(res);
    }); // API RPC endpoints:

    app.post('/api/buildImage', (req, res) => {
      // Filtering is necessary because UI cannot have empty string
      this.emitter.emit('should-build', {
        envs: (0, _mapToArgs.default)(req.body.envs || {}).filter(item => item[0] && item[1])
      });
      res.json({
        status: 'ok'
      });
    });
    app.post('/api/executeAction', async (req, res) => {
      try {
        const result = await this.executeAction({
          name: req.body.name,
          args: (0, _mapToArgs.default)(req.body.args || {})
        });
        res.json({
          status: 'ok',
          result
        });
      } catch (error) {
        res.json({
          status: 'error',
          error: error && error.message
        });
      }
    });
    app.post('/api/writeConfig', async (req, res) => {
      const {
        config
      } = req.body;

      if (config && config.length && typeof config === 'string') {
        _sbFs.default.writeFile(this.configPaths.microservice, config).catch(logger.error);
      }

      res.json({
        status: 'ok'
      });
    });
    await new Promise(resolve => {
      this.serverRef = app.listen({
        port: this.port,
        hostname: '127.0.0.1'
      }, resolve);
    });
  }

  handleConfigUpdated(microserviceConfig) {
    this.microserviceConfig = microserviceConfig;
    this.publishEvent('config-updated', {
      config: microserviceConfig,
      validationErrors: (0, _config.getValidationErrors)(microserviceConfig)
    });
  }

  handleAppStatusUpdated(status) {
    this.appStatus = status;
    this.publishEvent('app-status-updated', {
      status
    });
  }

  handleDockerLog({
    stream,
    contents
  }) {
    this.logToHistory('docker-log', {
      stream,
      contents: (0, _stripAnsi.default)(contents)
    });
  }

  logToHistory(type, payload) {
    this.publishEvent(type, payload); // Keep them both separately so restarting app often
    // doesn't remove Docker logs from the stack

    let countDockerLogs = 0;
    let countConsoleLogs = 0;
    const logHistory = []; // Temporarily store them in present->past order

    const reversedLogHistory = this.logHistory.slice().concat([{
      type,
      payload
    }]);
    reversedLogHistory.reverse();
    reversedLogHistory.forEach(item => {
      if (item.type === 'docker-log' && countDockerLogs < MAX_HISTORY_LENGTH) {
        logHistory.push(item);
        countDockerLogs += 1;
      } else if (item.type === 'console-log' && countConsoleLogs < MAX_HISTORY_LENGTH) {
        logHistory.push(item);
        countConsoleLogs += 1;
      }
    }); // Now that we're done filtering, reverse once more to make it all in past->present order

    this.logHistory = logHistory.reverse();
  }

  publishEvent(type, payload, connection) {
    const serialized = `${JSON.stringify({
      type,
      payload
    })}\n`;

    if (connection) {
      connection.write(serialized);
    } else {
      this.eventListeners.forEach(resp => {
        resp.write(serialized);
      });
    }
  }

  onShouldBuild(callback) {
    return this.emitter.on('should-build', callback);
  }

  onDidDestroy(callback) {
    this.emitter.on('did-destroy', callback);
  }

  dispose() {
    const {
      serverRef
    } = this;

    if (serverRef) {
      serverRef.close();
      this.serverRef = null;
    }

    this.emitter.emit('did-destroy');
    this.subscriptions.dispose();
    this.eventListeners.forEach(item => {
      item.destroy();
    });
    this.eventListeners.clear();
  }

}

exports.default = DashboardHttpServer;