"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _getPort = _interopRequireDefault(require("get-port"));

var _eventKit = require("event-kit");

var logger = _interopRequireWildcard(require("../../logger"));

var _daemon = require("../daemon");

var _action = require("../action");

var _types = require("../../types");

var _config = require("../config");

var _common = require("../../common");

var _DashboardHttpServer = _interopRequireDefault(require("./DashboardHttpServer"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Dashboard {
  constructor(options) {
    _defineProperty(this, "envs", void 0);

    _defineProperty(this, "image", void 0);

    _defineProperty(this, "inheritEnv", void 0);

    _defineProperty(this, "configPaths", void 0);

    _defineProperty(this, "microserviceConfig", void 0);

    _defineProperty(this, "appStatus", void 0);

    _defineProperty(this, "daemon", void 0);

    _defineProperty(this, "httpServer", void 0);

    _defineProperty(this, "subscriptions", void 0);

    this.envs = [];
    this.image = options.image;
    this.inheritEnv = options.inheritEnv;
    this.configPaths = options.configPaths;
    this.microserviceConfig = options.microserviceConfig;
    this.appStatus = _types.UIAppStatus.stopped;
    this.daemon = null;
    this.httpServer = null;

    _common.lifecycleDisposables.add(this);
  }

  async start(options) {
    const httpServer = new _DashboardHttpServer.default({
      port: options.port || (await (0, _getPort.default)({
        port: 9000
      })),
      configPaths: this.configPaths,
      microserviceConfig: this.microserviceConfig,
      appStatus: this.appStatus,
      executeAction: async ({
        name,
        args
      }) => {
        // Start the daemon if it dieded.
        if (!this.daemon) {
          await this.reload();
        }

        let response = null;
        await (0, _action.executeAction)({
          daemon: this.daemon,
          actionName: name,
          args,
          config: this.microserviceConfig,

          callback(_response) {
            response = _response;
          }

        });
        return response;
      }
    });
    httpServer.onShouldBuild(({
      envs
    }) => {
      this.envs = envs;
      this.reload().catch(logger.error);
    });
    await httpServer.start();
    const subscriptions = new _eventKit.CompositeDisposable();
    subscriptions.add(httpServer);
    subscriptions.add((0, _config.watchConfigFile)({
      validate: false,
      configPath: this.configPaths.microservice,
      onConfigUpdated: microserviceConfig => {
        this.microserviceConfig = microserviceConfig;
        httpServer.handleConfigUpdated(microserviceConfig);
        this.reload().catch(logger.error);
      }
    }));
    httpServer.onDidDestroy(() => {
      subscriptions.delete(httpServer);
    });
    this.httpServer = httpServer;
    this.subscriptions = subscriptions;
    return {
      port: httpServer.getPort()
    };
  }

  async reload() {
    const {
      daemon,
      httpServer
    } = this;

    if (!httpServer) {
      return;
    }

    if (daemon) {
      this.updateAppStatus(_types.UIAppStatus.stopped);
      this.daemon = null;
      daemon.stop().catch(logger.error);
    }

    this.updateAppStatus(_types.UIAppStatus.starting);
    const newDaemon = new _daemon.Daemon({
      configPaths: this.configPaths,
      microserviceConfig: this.microserviceConfig
    });
    this.daemon = newDaemon;

    try {
      await newDaemon.start({
        envs: this.envs,
        raw: true,
        image: this.image,
        inheritEnv: this.inheritEnv
      });
    } catch (error) {
      this.updateAppStatus(_types.UIAppStatus.stopped);
      throw error;
    }

    this.updateAppStatus(_types.UIAppStatus.started);
    const daemonLogs = await newDaemon.getLogs();
    daemonLogs.onLogLine(line => {
      httpServer.handleDockerLog({
        stream: 'stdout',
        contents: line
      });
    });
    daemonLogs.onErrorLine(line => {
      httpServer.handleDockerLog({
        stream: 'stderr',
        contents: line
      });
    });
  }

  updateAppStatus(appStatus) {
    const {
      httpServer
    } = this;
    this.appStatus = appStatus;

    if (httpServer) {
      httpServer.handleAppStatusUpdated(appStatus);
    }
  }

  dispose() {
    const {
      subscriptions
    } = this;

    if (subscriptions) {
      subscriptions.dispose();
    }

    _common.lifecycleDisposables.delete(this);
  }

}

exports.default = Dashboard;