"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = executeEventsAction;

var _got = _interopRequireDefault(require("got"));

var _express = _interopRequireDefault(require("express"));

var _bodyParser = _interopRequireDefault(require("body-parser"));

var _getPort = _interopRequireDefault(require("get-port"));

var _v = _interopRequireDefault(require("uuid/v4"));

var _eventKit = require("event-kit");

var logger = _interopRequireWildcard(require("../../logger"));

var _errors = require("../../errors");

var _common = require("../../common");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function executeEventsAction({
  daemon,
  argsMap,
  action,
  actionName,
  eventName,
  callback
}) {
  const event = action.events[eventName];

  if (!event) {
    throw new _errors.CLIError(`Action '${actionName}' has no event named '${eventName}'`);
  }

  const httpServer = (0, _express.default)();
  httpServer.use(_bodyParser.default.json());
  httpServer.use(_bodyParser.default.text());
  httpServer.use(_bodyParser.default.urlencoded({
    extended: false
  }));
  httpServer.post('/', (req, res) => {
    try {
      const retval = callback(req.body);

      if (retval && typeof retval.then === 'function') {
        retval.catch(logger.error);
      }
    } catch (error) {
      logger.error(error);
    }

    res.end('Done');
  });
  const httpServerPort = await (0, _getPort.default)();
  const httpServerSocket = httpServer.listen({
    port: httpServerPort,
    hostname: '127.0.0.1'
  });
  const disposable = new _eventKit.Disposable(() => {
    httpServerSocket.close();
  }); // Add to lifecycle disposables until the end of function
  // So if something happens during execution, the process
  // can end gracefully.

  _common.lifecycleDisposables.add(disposable);

  const id = (0, _v.default)();
  const containerEventPort = daemon.getContainerPort(event.http.port);
  const subscribePath = event.http.subscribe.path;
  const subscribeMethod = event.http.subscribe.method; // Subscribe to events

  try {
    await (0, _got.default)(`http://localhost:${containerEventPort}${subscribePath}`, {
      method: subscribeMethod,
      headers: {
        'content-type': 'application/json'
      },
      body: JSON.stringify({
        id,
        endpoint: `http://host.docker.internal:${httpServerPort}`,
        event: eventName,
        data: argsMap
      })
    });
  } catch (error) {
    const err = new _errors.CLIError(`HTTP Error when subscribing to ${subscribeMethod} ${subscribePath}`);
    let {
      body
    } = error && error.response || {
      body: ''
    };

    try {
      body = JSON.parse(body);
    } catch (_) {
      /* No op */
    }

    if (body) {
      // @ts-ignore
      err.response = body;
    }

    throw err;
  } // Remove from lifecycle disposables now that we're about to
  // return the disposable to caller function


  _common.lifecycleDisposables.remove(disposable);

  return {
    disposable
  };
}