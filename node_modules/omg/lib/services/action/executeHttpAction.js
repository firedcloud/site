"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = executeHttpAction;

var _got = _interopRequireDefault(require("got"));

var _formData = _interopRequireDefault(require("form-data"));

var _querystring = _interopRequireDefault(require("querystring"));

var _errors = require("../../errors");

var _validateActionOutput = _interopRequireDefault(require("./validateActionOutput"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const OUTPUT_TYPES_TO_PARSE = ['map', 'object'];
const OUTPUT_TYPE_TO_IGNORE = 'none';

async function executeHttpAction({
  daemon,
  action,
  actionName,
  argsMap
}) {
  const {
    path,
    method,
    port,
    url,
    contentType
  } = action.http;
  let uri;

  if (port) {
    const containerPort = daemon.getContainerPort(port);
    uri = `http://localhost:${containerPort}${path}`;
  } else if (url) {
    uri = url;
  } else {
    throw new _errors.CLIError(`Action#${actionName} has neither port+path nor url specified in config`);
  }

  let hasQueryArgs = false;
  const bodyArgs = {};
  const queryArgs = {};
  const headers = {
    Accept: 'application/json,text/plain,*/*'
  };
  Object.entries(action.arguments || {}).forEach(([argName, arg]) => {
    const argValue = argsMap[argName] || arg.default;

    if (arg.in === 'query' && argValue) {
      hasQueryArgs = true;
      queryArgs[argName] = argValue;
    }

    if (arg.in === 'requestBody' && argValue) {
      bodyArgs[argName] = argValue;
    }

    if (arg.in === 'path') {
      // Replace arg with empty value if non-existent
      uri.replace(`{${argName}}`, argValue || '');
    }

    if (arg.in === 'header') {
      headers[argName] = String(argValue);
    }
  });

  if (hasQueryArgs) {
    uri += uri.includes('?') ? '&' : '?';
    uri += _querystring.default.stringify(queryArgs);
  }

  let payload;

  if (contentType === 'application/x-www-form-urlencoded') {
    payload = _querystring.default.stringify(bodyArgs);
    headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
  } else if (contentType === 'multipart/form-data') {
    payload = new _formData.default();
    Object.entries(bodyArgs).forEach(([k, v]) => {
      payload.append(k, v);
    });
  } else {
    // JSON is the "default"
    payload = JSON.stringify(bodyArgs);
    headers['Content-Type'] = 'application/json';
  }

  let response;

  try {
    response = await (0, _got.default)(uri, {
      method,
      headers,
      body: payload,
      retry: 0,
      // ^ Disable retry
      followRedirect: false,
      throwHttpErrors: false
    });
  } catch (error) {
    // Got HTTP Error
    if (error && error.gotOptions) {
      const err = new _errors.CLIError(`Network Error ${error.code} on ${error.url}`);
      throw err;
    }

    throw error;
  } // Non 2XX Response


  if (response.statusCode < 200 || response.statusCode > 299) {
    const err = new _errors.CLIError(`Action#${actionName} returned non-OK Http Status ${response.statusCode}`);
    let {
      body
    } = response;

    try {
      body = JSON.parse(body);
    } catch (_) {}
    /* No op */
    // @ts-ignore


    err.response = body;
    throw err;
  }

  const outputType = action.output.type;
  let parsed = response.body;

  if (OUTPUT_TYPES_TO_PARSE.includes(outputType)) {
    try {
      parsed = JSON.parse(parsed);
    } catch (_) {
      throw new _errors.CLIError(`Action#${actionName} returned non-JSON output`);
    }
  } else if (outputType === OUTPUT_TYPE_TO_IGNORE) {
    parsed = null;
  }

  if (outputType !== OUTPUT_TYPE_TO_IGNORE) {
    (0, _validateActionOutput.default)({
      action,
      actionName,
      output: parsed
    });
  }

  return {
    response: parsed,
    disposable: null
  };
}