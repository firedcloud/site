"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = processActionArguments;

var _omgValidate = require("omg-validate");

var _argsToMap = _interopRequireDefault(require("../../helpers/argsToMap"));

var _errors = require("../../errors");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TYPES_TO_JSON_DECODE = ['list', 'object', 'map', 'int', 'number', 'float', 'boolean']; // Non-object ones are added to eg. convert from String int to Number int before validation

function processActionArguments({
  config,
  actionName,
  eventName,
  transform,
  args
}) {
  const action = config.actions && config.actions[actionName] || null;
  const values = {};

  if (!action) {
    throw new _errors.CLIError(`Action#${actionName} not found`);
  }

  let actionArgs;

  if (action.http) {
    actionArgs = action.arguments;
  } else if (action.events) {
    if (!eventName) {
      throw new _errors.CLIError(`Missing event name for Action#${actionName}`);
    }

    const event = action.events[eventName];

    if (!event) {
      throw new _errors.CLIError(`Action '${actionName}' has no event named '${eventName}'`);
    }

    actionArgs = event.arguments;
  }

  const extra = [];
  const missing = [];
  const invalid = [];
  const argsMap = (0, _argsToMap.default)(args);
  const argsNames = Object.keys(argsMap);
  const argsUsed = new Set(); // Step 1 - Map

  Object.entries(actionArgs || {}).forEach(([argName, arg]) => {
    const value = argsMap[argName];

    if (typeof value !== 'undefined') {
      argsUsed.add(argName);

      if (value !== null) {
        // ^ Null is eq to undefined in storyscript world
        values[argName] = value;
      }
    } else if (arg.required) {
      missing.push(argName);
    } else if (arg.default) {
      values[argName] = arg.default;
    }
  });

  if (argsUsed.size !== argsNames.length) {
    extra.push(...argsNames.filter(item => !argsUsed.has(item)));
  } // Step 2 - Transform


  if (transform) {
    // We try to parse these args from the CLI in following types:
    // - JSON
    Object.entries(actionArgs || {}).forEach(([argName, arg]) => {
      let value = argsMap[argName];
      let changed = false;

      if (typeof value !== 'string' || arg.type === 'string') {
        // We only unravel string args coming from CLI here
        return;
      }

      if (TYPES_TO_JSON_DECODE.includes(arg.type)) {
        // Try to parse as JSON
        try {
          value = JSON.parse(value);
          changed = true;
        } catch (_) {
          /* No op */
        }
      }

      if (changed) {
        values[argName] = value;
      }
    });
  } // Step 3 - Validate


  Object.entries(actionArgs || {}).forEach(([argName, arg]) => {
    const value = argsMap[argName];

    if (typeof value === 'undefined') {
      // Skip missing ones
      return;
    }

    invalid.push(...(0, _omgValidate.validateArgout)(arg, value).map(item => `${argName}${item.slice(1)}`));
  });
  return {
    extra,
    missing,
    invalid,
    values
  };
}