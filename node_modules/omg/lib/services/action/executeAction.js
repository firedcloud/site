"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = executeAction;

var _errors = require("../../errors");

var _executeHttpAction = _interopRequireDefault(require("./executeHttpAction"));

var _executeEventsAction = _interopRequireDefault(require("./executeEventsAction"));

var _processActionArguments = _interopRequireDefault(require("./processActionArguments"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function executeAction({
  daemon,
  config,
  actionName,
  eventName,
  args,
  transformedArgs,
  callback
}) {
  const action = config.actions && config.actions[actionName] || null;

  if (!action) {
    throw new _errors.CLIError(`Action#${actionName} not found`);
  } // Validate all actions have requested arguments


  const {
    extra: extraArgs,
    missing: missingArgs,
    invalid: invalidArgs,
    values: argsMap
  } = (0, _processActionArguments.default)({
    actionName,
    eventName,
    args: transformedArgs || args,
    config,
    transform: !transformedArgs
  });
  const totalCount = missingArgs.length + invalidArgs.length + extraArgs.length;

  if (totalCount > 0) {
    const chunks = [];

    if (missingArgs.length) {
      chunks.push(`${missingArgs.join(', ')} ${missingArgs.length > 1 ? 'are' : 'is'} missing`);
    }

    if (invalidArgs.length) {
      chunks.push(`${invalidArgs.join(', ')} ${invalidArgs.length > 1 ? 'are' : 'is'} invalid`);
    }

    if (extraArgs.length) {
      chunks.push(`${extraArgs.join(', ')} ${extraArgs.length > 1 ? 'are' : 'is'} unrecognized`);
    }

    throw new _errors.CLIError(`Invalid argument${totalCount > 1 ? 's' : ''} for Action#${actionName}: ${chunks.join(' and ')}`);
  }

  if (action.http != null) {
    const {
      response,
      disposable
    } = await (0, _executeHttpAction.default)({
      daemon,
      action,
      actionName,
      argsMap
    });
    callback(response);
    return disposable;
  }

  if (action.events != null) {
    if (!eventName) {
      throw new _errors.CLIError(`Missing event name for Action#${actionName}`);
    }

    const {
      disposable
    } = await (0, _executeEventsAction.default)({
      daemon,
      argsMap,
      action,
      actionName,
      eventName,
      callback
    });
    return disposable;
  }

  throw new _errors.CLIError(`Action#${actionName} has none of http/events specified`);
}