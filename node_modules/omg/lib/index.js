"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = main;

var _commander = _interopRequireDefault(require("commander"));

var _package = _interopRequireDefault(require("../package.json"));

var commands = _interopRequireWildcard(require("./commands"));

var logger = _interopRequireWildcard(require("./logger"));

var _common = require("./common");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getCollector(name) {
  return (val, memo) => {
    const eqIdx = val.indexOf('=');

    if (eqIdx === -1) {
      logger.fatal(`Invalid value for ${name}'s expected format of key=val: ${val}`);
    }

    const key = val.slice(0, eqIdx);
    const value = val.slice(eqIdx + 1);
    memo.push([key, value]);
    return memo;
  };
}

async function main() {
  let actionPromise;

  _commander.default.version(_package.default.version, '-v --version', 'Show OMG CLI version').description('For more details on the commands below, run `omg `(validate|build|run|subscribe)` --help`').option('-d --directory', 'Directory to use as root');

  _commander.default.command('validate').option('-j --json', 'Formats output to JSON').option('-s --silent', 'Only feedback is the status exit code').description('Validate the structure of a `microservice.yml` in the working directory').action(options => {
    (0, _common.setCliOptions)(options);

    if (options.json) {
      logger.setSymbolsAllowed(false);
    }

    actionPromise = commands.validate({
      options,
      parameters: []
    });
  });

  _commander.default.command('build').option('-t --tag, <t>', 'The tag name of the image').option('-r --raw', 'Show Docker build logs').description('Builds the microservice defined by the `Dockerfile`. Image will be tagged with `omg/$gihub_user/$repo_name`, unless the tag flag is given. If no git config present a random string will be used').action(options => {
    (0, _common.setCliOptions)(options);

    if (options.raw) {
      logger.setSpinnerAllowed(false);
    }

    actionPromise = commands.build({
      options,
      parameters: []
    });
  });

  _commander.default.command('run <action>').option('-i --image <i>', 'The name of the image to spin up the microservice, if not provided a fresh image will be build based of the `Dockerfile`').option('-a --args <a>', 'Arguments to be passed to the event, must be of the form `key="value"`. These arguments may be JSON encoded for `map`, `list` and `object` types.', getCollector('args'), []).option('-e --envs <e>', 'Environment variables to be passed to run environment, must be of the form `key="value"`', getCollector('envs'), []).option('--inherit-env', 'Binds host env variable asked in the microservice.yml to the container env').option('-r --raw', 'Show docker build logs').option('--silent', 'Hide output except for action result').option('--debug', 'Show container logs in CLI (for debugging purpose)').description('Run actions defined in your `microservice.yml`. Must be ran in a working directory with a `Dockerfile` and a `microservice.yml`').action(async (action, options) => {
    (0, _common.setCliOptions)(options);

    if (options.silent || options.raw) {
      logger.setSpinnerAllowed(false);
    }

    if (options.silent) {
      logger.setSymbolsAllowed(false);
    }

    actionPromise = commands.run({
      options,
      parameters: [action]
    });
  });

  _commander.default.command('subscribe <action> <event>').option('-i --image <i>', 'The name of the image to spin up the microservice, if not provided a fresh image will be build based of the `Dockerfile`').option('-a --args <a>', 'Arguments to be passed to the event, must be of the form `key="value"`. These arguments may be JSON encoded for `map`, `list` and `object` types.', getCollector('args'), []).option('-e --envs <e>', 'Environment variables to be passed to run environment, must be of the form `key="value"`', getCollector('envs'), []).option('--inherit-env', 'Binds host env variable asked in the microservice.yml to the container env').option('-r --raw', 'Show docker build logs').option('--silent', 'Hide output except for action result').option('--debug', 'Show container logs in CLI (for debugging purpose)').description('Subscribe to an event defined in your `microservice.yml`. Must be ran in a working directory with a `Dockerfile` and a `microservice.yml`').action(async (action, event, options) => {
    (0, _common.setCliOptions)(options);

    if (options.silent || options.raw) {
      logger.setSpinnerAllowed(false);
    }

    if (options.silent) {
      logger.setSymbolsAllowed(false);
    }

    actionPromise = commands.subscribe({
      options,
      parameters: [action, event]
    });
  });

  _commander.default.command('ui').option('-i --image <i>', 'The name of the image to spin up the microservice, if not provided a fresh image will be build based of the `Dockerfile`').option('-p --port, <p>', 'The port to bind').option('--no-open', 'Do not open in browser').option('--inherit-env', 'Binds host env variable asked in the microservice.yml to the container env').description('Starts to omg-app which monitors your microservice.').action(options => {
    (0, _common.setCliOptions)(options);
    actionPromise = commands.ui({
      options,
      parameters: []
    });
  });

  _commander.default.command('list').option('-j --json', 'Returns actions in json format').option('--pretty', 'Works with --json to show prettified json').option('-d --details', 'Returns detailed actions').description('Lists all actions available in microservice.').action(options => {
    (0, _common.setCliOptions)(options);

    if (options.json) {
      logger.setSymbolsAllowed(false);
    }

    actionPromise = commands.list({
      options,
      parameters: []
    });
  });

  _commander.default.on('--help', () => {
    console.log('');
    console.log('Environment Variables recognized by the CLI:');
    console.log('  OMS_CLI_DEBUG=true\t\t\tTo print stack traces of errors/issues');
  }); // The order is important, this has to be before the args length check.


  _commander.default.parse(process.argv);

  if (!actionPromise) {
    _commander.default.help();

    process.exit(1);
  }

  await actionPromise.catch(error => {
    logger.spinnerStop();
    logger.error(error);
  });
}