"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = list;

var logger = _interopRequireWildcard(require("../logger"));

var _config = require("../services/config");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

async function list({
  options
}) {
  const configPaths = await (0, _config.getConfigPaths)(options, true, false);
  const microserviceConfig = await (0, _config.parseMicroserviceConfig)({
    configPath: configPaths.microservice,
    validate: true
  });

  if (options.json) {
    logger.info(JSON.stringify(microserviceConfig.actions, null, options.pretty ? 2 : 0));
    return;
  }

  const {
    actions
  } = microserviceConfig;

  if (!actions) {
    return;
  }

  if (options.details) {
    Object.entries(actions).forEach(([actionName, action], i, actionEntries) => {
      logger.info(`${actionName}: ${action.help ? action.help.trim() : 'No help provided'}`);
      const {
        events,
        http
      } = action;

      if (http) {
        const args = Object.entries(action.arguments || {});
        let uri = `:${http.port}${http.path}`;
        const query = args.filter(([_, arg]) => arg.in === 'query').map(([name]) => `${name}=<arg>`).join('&');
        const body = args.filter(([_, arg]) => arg.in === 'requestBody').map(([name, arg]) => `${name}=${arg.type}`);

        if (query.length) {
          uri = `${uri}?${query}`;
        }

        logger.info(`${http.method.toUpperCase()} ${uri} ${body.join(' ')}`);
      } else if (events) {
        Object.entries(events).forEach(([eventName, event]) => {
          logger.info(`  ${eventName}: ${event.help ? event.help.trim() : 'No help provided'}`); // TODO: Subscribe/Unsubscribe?
        });
      } // Only emit an empty line for non-last items


      if (i < actionEntries.length - 1) {
        console.log('');
      }
    });
    return;
  }

  Object.entries(actions).forEach(([key, value], i) => {
    logger.info(`${key}: ${value.help ? value.help.trim() : 'No help provided'}\n`);
  });
}