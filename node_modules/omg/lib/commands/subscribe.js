"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = subscribe;

var _get2 = _interopRequireDefault(require("lodash/get"));

var logger = _interopRequireWildcard(require("../logger"));

var _daemon = require("../services/daemon");

var _action = require("../services/action");

var _config = require("../services/config");

var _common = require("../common");

var _common2 = require("./_common");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function subscribe({
  options,
  parameters
}) {
  const configPaths = await (0, _config.getConfigPaths)(options, true, !options.image);
  const microserviceConfig = await (0, _config.parseMicroserviceConfig)({
    configPath: configPaths.microservice,
    validate: true
  });
  const [actionName, eventName] = parameters;

  if (!actionName) {
    logger.fatal(`No action name specified. ${_common.HELP_OMG_LIST}`);
  }

  const actionConfig = (0, _get2.default)(microserviceConfig, ['actions', actionName]);

  if (!actionConfig) {
    logger.fatal(`Action '${actionName}' not found. ${_common.HELP_OMG_LIST}`);
  } else if (!actionConfig.events) {
    logger.fatal(`Action '${actionName}' has no events specified. ${_common.HELP_OMG_LIST}`);
  }

  if (!actionConfig.events[eventName]) {
    logger.fatal(`Action '${actionName}' has no event named '${eventName}'. ${_common.HELP_OMG_LIST_DETAILS}`);
  }

  const validatatedArguments = (0, _common2.validateActionArguments)({
    actionName,
    eventName,
    args: options.args || [],
    config: microserviceConfig
  });
  const validatedEnv = (0, _common2.validateContainerEnv)({
    config: microserviceConfig,
    envs: options.envs || [],
    inheritEnv: !!options.inheritEnv
  });

  if (!validatedEnv || !validatatedArguments) {
    return;
  }

  const daemon = new _daemon.Daemon({
    configPaths,
    microserviceConfig
  });
  await daemon.start({
    envs: options.envs || [],
    image: options.image,
    raw: !!options.raw,
    inheritEnv: !!options.inheritEnv
  });

  if (options.debug) {
    const daemonLogger = await daemon.getLogs();
    daemonLogger.onLogLine(line => {
      logger.info(line);
    });
    daemonLogger.onErrorLine(line => {
      logger.error(line);
    });
  }

  logger.spinnerStart('Performing Healthcheck');

  if (!(await daemon.ping())) {
    logger.spinnerFail('Healthcheck failed');

    if (options.raw) {
      logger.error('Healthcheck failed');
    }

    process.exitCode = 1;
    return;
  }

  logger.spinnerSucceed('Healthcheck successful');
  logger.spinnerStart(`Subscribing to '${actionName}' / '${eventName}'`);
  const disposable = await (0, _action.executeAction)({
    config: microserviceConfig,
    daemon,
    actionName,
    eventName,
    args: options.args || [],

    callback(response) {
      if (options.silent) {
        logger.info(response && typeof response === 'object' ? JSON.stringify(response, null, 2) : response);
      } else {
        logger.info(`Event received: ${JSON.stringify(response, null, 2)}`);
      }
    }

  });

  if (disposable) {
    _common.lifecycleDisposables.add(disposable);
  }

  logger.spinnerSucceed(`Successfully subscribed to event`);
}