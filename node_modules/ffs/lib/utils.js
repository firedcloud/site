(function(){
  var fs, path, pinky, liftNode, ref$, pipeline, all, list, status, walkTree;
  fs = require('fs');
  path = require('path');
  pinky = require('pinky');
  liftNode = require('pinky-for-fun').liftNode;
  ref$ = require('pinky-combinators'), pipeline = ref$.pipeline, all = ref$.all;
  list = liftNode(fs.readdir);
  status = liftNode(fs.stat);
  walkTree = curry$(function(stepper, pathName){
    return status(pathName).then(function(info){
      switch (false) {
      case !info.isDirectory():
        return diveIn();
      default:
        return stepper(pathName);
      }
    });
    function diveIn(){
      var keepStepping, files, stepFiles;
      keepStepping = walkTree(stepper);
      files = list(pathName);
      stepFiles = function(){
        return files.then(function(xs){
          return all(xs.map(compose$([keepStepping, fixPath])));
        });
      };
      return pipeline([
        stepFiles, function(){
          return stepper(pathName);
        }
      ]);
    }
    function fixPath(fileName){
      return path.join(pathName, fileName);
    }
    return fixPath;
  });
  module.exports = {
    walkTree: walkTree
  };
  function compose$(fs){
    return function(){
      var i, args = arguments;
      for (i = fs.length; i > 0; --i) { args = [fs[i-1].apply(this, args)]; }
      return args[0];
    };
  }
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
}).call(this);
