(function(){
  var path, fs, pinky, liftNode, ref$, pipeline, all, walkTree, parent, alreadyExists, doesntExist, mkdir, make, makeRecursive, list, listRecursive;
  path = require('path');
  fs = require('fs');
  pinky = require('pinky');
  liftNode = require('pinky-for-fun').liftNode;
  ref$ = require('pinky-combinators'), pipeline = ref$.pipeline, all = ref$.all;
  walkTree = require('./utils').walkTree;
  parent = function(p){
    return path.resolve(p, '..');
  };
  alreadyExists = function(err){
    return err.code === 'EEXIST';
  };
  doesntExist = function(err){
    return err.code === 'ENOENT';
  };
  mkdir = liftNode(fs.mkdir);
  make = curry$(function(mode, pathName){
    return mkdir(pathName, mode);
  });
  makeRecursive = curry$(function(mode, pathName){
    var promise;
    promise = pinky();
    make(mode, pathName).then(function(_){
      return promise.fulfill();
    }, function(error){
      var p;
      switch (false) {
      case !alreadyExists(error):
        return promise.fulfill();
      case !doesntExist(error):
        p = pipeline([
          function(){
            return makeRecursive(mode, parent(pathName));
          }, function(){
            return make(mode, pathName);
          }
        ]);
        return p.then(function(){
          return promise.fulfill();
        }, promise.reject);
      default:
        return promise.reject(error);
      }
    });
    return promise;
  });
  list = liftNode(fs.readdir);
  listRecursive = function(dir){
    return list(dir).then(function(files){
      return all(files.map(compose$([
        maybeList, function(it){
          return path.join(dir, it);
        }
      ]))).then(flatten);
    });
    function flatten(xs){
      switch (false) {
      case xs.length !== 0:
        return [];
      default:
        return xs.reduce(curry$(function(x$, y$){
          return x$.concat(y$);
        }));
      }
    }
    function maybeList(x){
      return liftNode(fs.stat)(x).then(function(stats){
        switch (false) {
        case !stats.isDirectory(x):
          return listRecursive(x).then(function(it){
            return [x].concat(it);
          });
        case !stats.isFile(x):
          return pinky([x]);
        }
      });
    }
    return maybeList;
  };
  module.exports = {
    make: make,
    makeRecursive: makeRecursive,
    list: list,
    listRecursive: listRecursive
  };
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
  function compose$(fs){
    return function(){
      var i, args = arguments;
      for (i = fs.length; i > 0; --i) { args = [fs[i-1].apply(this, args)]; }
      return args[0];
    };
  }
}).call(this);
